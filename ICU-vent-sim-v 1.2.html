<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>ICU Ventilator Simulator v 1.2 (Sep, 2025) — Prof Jyotirmay Kirtania • CC BY-NC</title>
<style>
  :root{
    --bg:#0a0f16; --panel:#111826; --accent:#18c2a5; --accent2:#4fd1c5; --ink:#eaf6ff; --muted:#9fb3d9;
    --warn:#ffd166; --danger:#ff6b6b; --ok:#06d6a0; --grid:#1b2a41; --info:#4fa3ff;
  }
  html,body{height:100%}
  body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial}
  .app{display:grid;grid-template-columns:360px 1fr;gap:12px;height:100%;}
  .sidebar{background:var(--panel);padding:14px;display:flex;flex-direction:column;gap:14px;box-shadow:0 0 0 1px #0e1726 inset;overflow:auto}
  .brand{display:flex;align-items:center;gap:10px}
  .led{width:10px;height:10px;border-radius:50%;background:#394b63;box-shadow:0 0 6px #000 inset}
  .led.on{background:var(--ok);box-shadow:0 0 12px var(--ok)}
  h1{font-size:16px;margin:0;font-weight:700;letter-spacing:.3px;color:#d7efff}
  .row{display:grid;grid-template-columns:1fr auto;align-items:center;gap:10px}
  .group{border:1px solid #1a2940;border-radius:12px;padding:12px;background:#0f1624}
  .group h2{margin:0 0 8px 0;font-size:13px;font-weight:800;color:#bfe3ff;text-transform:uppercase;letter-spacing:.8px}
  .control{display:grid;grid-template-columns:1fr 90px;gap:8px;align-items:center;margin:6px 0}
  .sublabel{display:block;font-size:10px;color:#9fb3d9;margin-top:2px}
  .unit{font-size:10px;color:#9fb3d9;margin-left:6px}
  .control label{font-size:12px;color:#cfe6ff}
  .control output{justify-self:end;font-variant-numeric:tabular-nums;background:#0c1320;padding:2px 6px;border-radius:6px;min-width:72px;text-align:right}
  input[type=range]{width:100%}
  select,button{background:#0c1320;border:1px solid #223655;color:#eaf6ff;border-radius:10px;padding:8px 10px;font-weight:600}
  button{cursor:pointer}
  button.primary{background:linear-gradient(180deg,var(--accent),var(--accent2));color:#07363a;border:none}
  button.warn{background:linear-gradient(180deg,#ff9f43,#ff6b6b);border:none}
  .btn-ghost{background:#0c1320;border:1px solid #2a3d5f}
  .monitor{display:grid;grid-template-rows:auto auto 1fr;gap:8px;padding:10px}
  .topbar{display:grid;grid-template-columns:1fr auto auto;gap:12px;align-items:center}
  .kpi{display:grid;grid-auto-flow:column;gap:10px;align-items:stretch}
  .kpi .card{background:var(--panel);padding:8px 10px;border-radius:12px;border:1px solid #1a2940;min-width:112px}
  .kpi .card .label{color:#9fb3d9;font-size:10px;text-transform:uppercase;letter-spacing:.6px}
  .kpi .card .value{font-size:20px;font-weight:800;font-variant-numeric:tabular-nums}
  .kpi .card .unit{font-size:10px;color:#9fb3d9;margin-left:4px}
  .alarms{display:flex;gap:8px;flex-wrap:wrap;min-height:32px}
  .alarm{padding:6px 10px;border-radius:10px;border:1px solid #2a3d5f;background:#0c1526;color:#fff;font-size:12px;display:flex;gap:8px;align-items:center;animation:flash 1s linear infinite;}
  .alarm.warn{background:#2b210c;border-color:#5a3b0b;color:#ffd166}
  .alarm.danger{background:#2b0e0e;border-color:#6b1b1b;color:#ffb4b4}
  .alarm.info{background:#0b1e2e;border-color:#1f4a7a;color:#b7d5ff}
  @keyframes flash{0%,60%{filter:brightness(1)}61%,100%{filter:brightness(1.7)}}
  .screens{display:grid;grid-template-columns:1fr;gap:8px}
  .screen{background:linear-gradient(180deg,#0f1929,#0a111b);border:1px solid #1a2940;border-radius:14px;padding:8px}
  .plot{height:120px;position:relative}
  canvas{width:100%;height:100%;display:block}
  .legend{position:absolute;right:10px;top:6px;font-size:10px;color:#cfe6ff;background:#0b1322aa;padding:3px 6px;border-radius:8px;border:1px solid #213551}
  .axisBadge{position:absolute;left:8px;top:6px;font-size:10px;color:#cfe6ff;background:#0b1322aa;padding:3px 6px;border-radius:8px;border:1px solid #213551}
  .footer{display:flex;justify-content:space-between;align-items:center;padding:6px 10px;color:#9fb3d9;font-size:12px}
  dialog{border:1px solid #223655;border-radius:12px;background:#0b1220;color:#eaf6ff;max-width:680px;width:clamp(320px,90vw,680px)}
  dialog::backdrop{background:#0008;backdrop-filter:blur(2px)}
  .grid{display:grid;gap:8px}
  .grid2{display:grid;grid-template-columns:1fr 1fr;gap:8px}
  .grid3{display:grid;grid-template-columns:repeat(3,1fr);gap:8px}
  .chip{background:#0c1320;border:1px solid #2a3d5f;border-radius:10px;padding:6px 8px;font-size:12px}
  /* Freeze styling */
  .frozen{opacity:.45; pointer-events:none; filter:saturate(.4)}
  /* White digits for alarm inputs */
  .whiteDigits{color:#fff !important;background:#0c1320;border:1px solid #2a3d5f;border-radius:10px;padding:6px 8px;font-weight:700}
</style>
</head>
<body>
<div class="app">
  <!-- Left control panel -->
  <aside class="sidebar">
    <div class="brand">
      <div class="led" id="led"></div>
      <h1>ICU Ventilator Simulator v 1.2 (Sep, 2025)</h1>
    </div>
    <div class="sublabel">Copyright © Prof Jyotirmay Kirtania • CC BY-NC</div>

    <!-- Mode & Timing -->
    <div class="group">
      <h2>Mode & Timing</h2>
      <div class="control" id="ctl_mode">
        <label for="mode">Mode <span class="unit">—</span></label>
        <select id="mode">
          <option value="VC-AC">VC-AC</option>
          <option value="PC-AC">PC-AC</option>
          <option value="PRVC">PRVC</option>
          <option value="APRV">APRV</option>
          <option value="PSV">PSV + PEEP (apnea backup)</option>
        </select>
      </div>
      <div class="control" id="ctl_rr">
        <label>RR <span class="unit">bpm</span></label>
        <input type="range" id="rr" min="6" max="40" step="1" value="16" />
        <output id="rrOut">16</output>
      </div>
      <div class="control" id="ctl_ie">
        <label>I:E <span class="unit">ratio</span></label>
        <input type="range" id="ie" min="1" max="5" step="0.1" value="2.0" />
        <output id="ieOut">1:2.0</output>
      </div>
      <div class="control" id="ctl_tpct">
        <label>Tp/Ti (insp pause) <span class="unit">%</span></label>
        <input type="range" id="tpct" min="0" max="30" step="1" value="0" />
        <output id="tpctOut">0%</output>
      </div>
      <div class="control" id="ctl_peep">
        <label>PEEP <span class="unit">cmH₂O</span></label>
        <input type="range" id="peep" min="0" max="20" step="1" value="5" />
        <output id="peepOut">5</output>
      </div>
      <div class="control">
        <label>FiO₂ <span class="unit">%</span></label>
        <input type="range" id="fio2" min="21" max="100" step="1" value="40" />
        <output id="fio2Out">40%</output>
      </div>
    </div>

    <!-- Targets -->
    <div class="group">
      <h2>Targets</h2>
      <div class="control" data-mode="VC-AC">
        <label>VT <span class="unit">mL</span></label>
        <input type="range" id="vt" min="200" max="800" step="10" value="450" />
        <output id="vtOut">450</output>
      </div>
      <div class="control" data-mode="PC-AC">
        <label>Pinsp (above PEEP) <span class="unit">cmH₂O</span></label>
        <input type="range" id="pinsp" min="5" max="35" step="1" value="16" />
        <output id="pinspOut">16</output>
      </div>
      <div class="control" data-mode="PRVC">
        <label>Target VT <span class="unit">mL</span></label>
        <input type="range" id="prvcVT" min="200" max="800" step="10" value="420" />
        <output id="prvcVTOut">420</output>
      </div>
      <div class="control" data-mode="PRVC">
        <label>Max Pinsp <span class="unit">cmH₂O</span></label>
        <input type="range" id="prvcPmax" min="15" max="40" step="1" value="28" />
        <output id="prvcPmaxOut">28</output>
      </div>
      <div class="control" data-mode="APRV">
        <label>P<sub>High</sub> <span class="unit">cmH₂O</span></label>
        <input type="range" id="aprvPhigh" min="10" max="35" step="1" value="24" />
        <output id="aprvPhighOut">24</output>
      </div>
      <div class="control" data-mode="APRV">
        <label>P<sub>Low</sub> <span class="unit">cmH₂O</span></label>
        <input type="range" id="aprvPlow" min="0" max="10" step="1" value="5" />
        <output id="aprvPlowOut">5</output>
      </div>
      <div class="control" data-mode="APRV">
        <label>T<sub>High</sub> <span class="unit">s</span></label>
        <input type="range" id="aprvTH" min="0.5" max="8" step="0.1" value="4" />
        <output id="aprvTHOut">4.0</output>
      </div>
      <div class="control" data-mode="APRV">
        <label>T<sub>Low</sub> <span class="unit">s</span></label>
        <input type="range" id="aprvTL" min="0.2" max="1.5" step="0.05" value="0.5" />
        <output id="aprvTLOut">0.50</output>
      </div>
      <div class="control" data-mode="PSV">
        <label>PSupport <span class="unit">cmH₂O</span></label>
        <input type="range" id="ps" min="5" max="25" step="1" value="12" />
        <output id="psOut">12</output>
      </div>
      <div class="control" data-mode="PSV">
        <label>Cycle-off (flow) <span class="unit">%</span></label>
        <input type="range" id="cyclePct" min="5" max="50" step="1" value="25" />
        <output id="cyclePctOut">25%</output>
      </div>
      <div class="control" data-mode="PSV">
        <label>Apnea Time <span class="unit">s</span></label>
        <input type="range" id="apneaT" min="5" max="30" step="1" value="20" />
        <output id="apneaTOut">20</output>
      </div>
      <div class="control" data-mode="PSV">
        <label>Backup RR <span class="unit">bpm</span></label>
        <input type="range" id="backupRR" min="6" max="30" step="1" value="14" />
        <output id="backupRROut">14</output>
      </div>
      <div class="control" data-mode="PSV">
        <label>Backup Type <span class="unit">—</span></label>
        <select id="backupType">
          <option value="VC-AC">VC-AC</option>
          <option value="PC-AC">PC-AC</option>
        </select>
      </div>
      <div class="control" data-mode="PSV">
        <label>Backup Target <span class="unit">mL or cmH₂O*</span></label>
        <input type="range" id="backupTarget" min="200" max="800" step="10" value="420" />
        <output id="backupTargetOut">420</output>
      </div>
      <div class="sublabel">*If Backup Type = PC-AC, Pinsp≈Target/20.</div>
      <div class="control">
        <label>Trigger <span class="unit">L/min</span></label>
        <input type="range" id="trigger" min="-5" max="-1" step="0.5" value="-2" />
        <output id="triggerOut">-2</output>
      </div>
    </div>

    <!-- Lung mechanics & issues -->
    <div class="group">
      <h2>Lung Mechanics & Issues</h2>
      <div class="control">
        <label>Compliance C <span class="unit">mL/cmH₂O</span></label>
        <input type="range" id="compliance" min="10" max="120" step="2" value="60" />
        <output id="complianceOut">60</output>
      </div>
      <div class="control">
        <label>Resistance R <span class="unit">cmH₂O·s/L</span></label>
        <input type="range" id="resistance" min="4" max="40" step="1" value="12" />
        <output id="resistanceOut">12</output>
      </div>
      <div class="control">
        <label>Patient Effort <span class="unit">cmH₂O</span></label>
        <input type="range" id="effort" min="0" max="10" step="1" value="0" />
        <output id="effortOut">0</output>
      </div>
      <div class="control">
        <label>Asynchrony <span class="unit">%</span></label>
        <input type="range" id="asyncPct" min="0" max="100" step="5" value="0" />
        <output id="asyncPctOut">0%</output>
      </div>
      <div class="control">
        <label>Expiratory Limitation <span class="unit">—</span></label>
        <input type="range" id="expLimit" min="0" max="1" step="0.05" value="0" />
        <output id="expLimitOut">0</output>
      </div>
      <div class="control">
        <label>Bronchospasm <span class="unit">0–3</span></label>
        <input type="range" id="broncho" min="0" max="3" step="1" value="0" />
        <output id="bronchoOut">0</output>
      </div>
      <div class="control">
        <label>Leak <span class="unit">%</span></label>
        <input type="range" id="leakPct" min="0" max="100" step="5" value="0" />
        <output id="leakPctOut">0%</output>
      </div>
      <div class="row" style="gap:8px;align-items:center">
        <label for="disconnect" style="font-size:12px;color:#cfe6ff">Circuit Disconnection</label>
        <button id="disconnect" class="warn">Disconnected: OFF</button>
      </div>
    </div>

    <!-- Soft keys -->
    <div class="group">
      <h2>Soft Keys</h2>
      <div class="grid3">
        <button class="btn-ghost" id="alarmSetupBtn">Alarm Setup</button>
        <button class="btn-ghost" id="scenariosBtn">Clinical Scenarios</button>
        <button class="btn-ghost" id="freezeBtn">Freeze</button>
      </div>
    </div>

    <!-- Simulation controls -->
    <div class="group">
      <h2>Simulation</h2>
      <div class="row">
        <button class="primary" id="start">Start</button>
        <button id="pause">Pause</button>
        <button class="warn" id="stop">Stop</button>
      </div>
      <div class="sublabel" id="status">Stopped</div>
    </div>
  </aside>

  <!-- Right monitor panel -->
  <main class="monitor">
    <div class="topbar">
      <div class="kpi" id="kpis">
        <div class="card"><div class="label">RR (set / patient)</div><div class="value" id="kRR">-- / --</div><span class="unit">bpm</span></div>
        <div class="card"><div class="label">MV</div><div class="value" id="kMV">--</div><span class="unit">L/min</span></div>
        <div class="card"><div class="label">Ppeak</div><div class="value" id="kPpeak">--</div><span class="unit">cmH₂O</span></div>
        <div class="card"><div class="label">Pplat</div><div class="value" id="kPplat">--</div><span class="unit">cmH₂O</span></div>
        <div class="card"><div class="label">VT exp</div><div class="value" id="kVT">--</div><span class="unit">mL</span></div>
        <div class="card"><div class="label">Auto-PEEP</div><div class="value" id="kAutoPEEP">--</div><span class="unit">cmH₂O</span></div>
        <div class="card"><div class="label">I:E</div><div class="value" id="kIE">--</div><span class="unit">ratio</span></div>
        <div class="card"><div class="label">WOB / breath</div><div class="value" id="kWOB">--</div><span class="unit">J</span></div>
        <div class="card"><div class="label">FiO₂</div><div class="value" id="kFiO2">40</div><span class="unit">%</span></div>
      </div>
      <div><button id="freeze">Freeze</button></div>
      <div class="sublabel" id="clock">--:--:--</div>
    </div>

    <div class="alarms" id="alarms"></div>

    <section class="screens">
      <div class="screen">
        <div class="plot"><canvas id="cPressure"></canvas><div class="axisBadge" id="pAxis">Scale: cmH₂O</div><div class="legend">Airway Pressure</div></div>
      </div>
      <div class="screen">
        <div class="plot"><canvas id="cFlow"></canvas><div class="axisBadge" id="fAxis">Scale: L/min</div><div class="legend">Flow</div></div>
      </div>
      <div class="screen">
        <div class="plot"><canvas id="cVolume"></canvas><div class="axisBadge" id="vAxis">Scale: mL</div><div class="legend">Volume</div></div>
      </div>
    </section>
    <div class="footer">
      <div>Educational simulator. Do not use for patient care.</div>
      <div>© 2025 • ICU Ventilator Simulator v 1.2</div>
    </div>
  </main>
</div>

<!-- Alarm Setup dialog -->
<dialog id="alarmDlg">
  <h3>Alarm Limits</h3>
  <div class="grid2" id="alarmGrid"></div>
  <div class="row" style="margin-top:8px;grid-template-columns:auto auto;gap:8px;justify-content:end">
    <button id="alarmClose">Close</button>
    <button class="primary" id="alarmSave">Save</button>
  </div>
  <p class="sublabel">Single flashing banners with tones; thresholds are editable.</p>
</dialog>

<!-- Scenarios dialog -->
<dialog id="scenDlg">
  <h3>Simulated Clinical Scenarios</h3>
  <div class="grid" id="scenGrid"></div>
  <div class="row" style="margin-top:8px;grid-template-columns:auto;justify-content:end">
    <button id="scenClose">Close</button>
  </div>
</dialog>

<script>
(function(){
  const $ = sel => document.querySelector(sel);
  const fmt = (v,d=0)=>Number(v).toFixed(d);

  // Live clock
  const clockEl = $('#clock');
  setInterval(()=>{const n=new Date();clockEl.textContent=`${String(n.getHours()).padStart(2,'0')}:${String(n.getMinutes()).padStart(2,'0')}:${String(n.getSeconds()).padStart(2,'0')}`;},1000);

  // ====== Strip charts ======
  class StripChart{
    constructor(c,opts){ this.c=c; this.x=c.getContext('2d'); this.o=Object.assign({seconds:10,yRange:[0,1],minSpan:1},opts||{}); this.d=[]; this.resize(); addEventListener('resize',()=>this.resize()); }
    resize(){ const r=devicePixelRatio||1; this.c.width=this.c.clientWidth*r; this.c.height=this.c.clientHeight*r; }
    push(y){ const t=performance.now()/1000; this.d.push([t,y]); const cut=t-this.o.seconds; while(this.d.length && this.d[0][0]<cut) this.d.shift(); }
    calcRange(){ if(!this.d.length) return this.o.yRange; let lo=Infinity, hi=-Infinity; for(const [,y] of this.d){ if(y<lo) lo=y; if(y>hi) hi=y; } if(hi-lo<this.o.minSpan){ const mid=(hi+lo)/2; lo=mid-this.o.minSpan/2; hi=mid+this.o.minSpan/2; } const pad=(hi-lo)*0.15; lo-=pad; hi+=pad; return [lo,hi]; }
    draw(){ const x=this.x,w=this.c.width,h=this.c.height; x.clearRect(0,0,w,h);
      x.strokeStyle=getComputedStyle(document.documentElement).getPropertyValue('--grid'); x.lineWidth=1; x.beginPath();
      for(let gx=0;gx<w;gx+=Math.max(30,w/20)){x.moveTo(gx,0);x.lineTo(gx,h);} for(let gy=0;gy<h;gy+=Math.max(20,h/10)){x.moveTo(0,gy);x.lineTo(w,gy);} x.stroke();
      if(!this.d.length) return; const [y0,y1]=this.calcRange(); const t0=this.d[0][0],t1=this.d[this.d.length-1][0];
      const sy=v=> h*(1-(v-y0)/(y1-y0)); const sx=t=> w*((t-t0)/(t1-t0||1));
      x.beginPath(); for(let i=0;i<this.d.length;i++){ const px=sx(this.d[i][0]), py=sy(this.d[i][1]); if(i==0) x.moveTo(px,py); else x.lineTo(px,py);} x.lineWidth=2; x.strokeStyle=getComputedStyle(document.documentElement).getPropertyValue('--accent2'); x.stroke();
      return [y0,y1];
    }
  }
  const pChart = new StripChart($('#cPressure'),{seconds:10,yRange:[-5,40],minSpan:10});
  const fChart = new StripChart($('#cFlow'),{seconds:10,yRange:[-60,60],minSpan:10});
  const vChart = new StripChart($('#cVolume'),{seconds:10,yRange:[0,800],minSpan:100});

  // ====== State ======
  const state = {
    mode:'VC-AC', RR:16, IE:2.0, tpct:0, PEEP:5, fio2:40,
    Pinsp:16, VT:450, trigger:-2,
    prvcVT:420, prvcPmax:28, prvcPinsp:16,
    aprvPhigh:24, aprvPlow:5, aprvTH:4.0, aprvTL:0.5, aprvPhase:'TH', aprvTimer:0,
    ps:12, cyclePct:25, apneaT:20, apneaTimer:0, backupRR:14, backupType:'VC-AC', backupTarget:420, backupActive:false,
    Cml:60, R:12, Effort:0, asyncPct:0, expLimit:0, broncho:0, leakPct:0, disconnected:false,
    running:false, freeze:false
  };

  // ====== Rolling windows for MV & RR (60 s) ======
  const SIM_DT = 0.01;
  const MV_WINDOW_SEC = 60, RR_WINDOW_SEC = 60;
  const mvEvents = []; // {t, L}
  const breathStarts = []; // {t, src: 'machine'|'patient'}
  function nowSec(){ return performance.now()/1000; }

  // Local dynamics
  let t=0, volume=0, flow=0, p_aw=5, p_peak=0, vt_exp=0, auto_peep=0;
  let cycleT, inspT, expT, cyclePhase='insp', timeInPhase=0, expStartVol=0, wobThisBreath=0, psvPeakFlow=0;

  // Plateau capture (from previous version)
  let inPause=false, platSum=0, platN=0, lastPplat=null;

  // Leak monitoring (EMA of leak fraction)
  let leakFracEMA = 0; const leakAlpha = 1 - Math.exp(-SIM_DT/3);

  function recalcTiming(){
    cycleT=60/state.RR;
    const inspBase = 1/(1+state.IE);
    const pauseFrac=Math.min(0.3, state.tpct/100);
    inspT = cycleT*inspBase; expT = cycleT - inspT;
    state._pauseTime = inspT*pauseFrac; state._activeInsp = Math.max(0.1, inspT - state._pauseTime);
    $('#kIE').textContent=`1:${fmt(state.IE,1)}`;
  }
  recalcTiming();

  // ====== Bind helpers + mode UI freezing ======
  function bindRange(id,key){
    const el=$('#'+id), out=$('#'+id+'Out'); if(!el) return;
    const upd=()=>{ state[key]=parseFloat(el.value);
      out&&(out.textContent=(id==='ie'?`1:${fmt(state[key],1)}`:
        (id==='tpct'?`${fmt(state[key],0)}%`:
          (id==='fio2'||id==='cyclePct'?`${fmt(state[key],0)}%`:
            fmt(state[key], id.includes('TH')||id.includes('TL')?2:0)))));
      if(key==='RR'||key==='IE'||key==='tpct') recalcTiming();
      if(id==='fio2') $('#kFiO2').textContent = fmt(state[key],0);
      if(id==='prvcVT' || id==='compliance'){ estimateInitialPRVCPinsp(); }
    };
    el.addEventListener('input',upd); upd();
  }

  function setControlFrozen(ctrlId, frozen){
    const wrap = $('#'+ctrlId);
    if(!wrap) return;
    const inputs = wrap.querySelectorAll('input,select,button');
    wrap.classList.toggle('frozen', frozen);
    inputs.forEach(el=> el.disabled = frozen);
  }

  function refreshModeUI(){
    const cur = state.mode;
    // Mode-specific blocks
    document.querySelectorAll('[data-mode]').forEach(control=>{
      const m = control.getAttribute('data-mode');
      const disable = (m !== cur);
      control.classList.toggle('frozen', disable);
      control.querySelectorAll('input,select,button').forEach(el=>{ el.disabled = disable; });
    });
    // APRV-specific: freeze RR, IE, PEEP, Tp/Ti
    const isAPRV = (cur==='APRV');
    setControlFrozen('ctl_rr', isAPRV);
    setControlFrozen('ctl_ie', isAPRV);
    setControlFrozen('ctl_peep', isAPRV);
    setControlFrozen('ctl_tpct', isAPRV);
  }

  $('#mode').addEventListener('change',()=>{
    state.mode=$('#mode').value;
    if(state.mode==='PRVC'){ estimateInitialPRVCPinsp(); }
    refreshModeUI();
  });

  bindRange('rr','RR'); bindRange('ie','IE'); bindRange('tpct','tpct'); bindRange('peep','PEEP'); bindRange('fio2','fio2');
  bindRange('vt','VT'); bindRange('pinsp','Pinsp'); bindRange('prvcVT','prvcVT'); bindRange('prvcPmax','prvcPmax');
  bindRange('aprvPhigh','aprvPhigh'); bindRange('aprvPlow','aprvPlow'); bindRange('aprvTH','aprvTH'); bindRange('aprvTL','aprvTL');
  bindRange('ps','ps'); bindRange('cyclePct','cyclePct'); bindRange('apneaT','apneaT'); bindRange('backupRR','backupRR'); bindRange('backupTarget','backupTarget');
  bindRange('trigger','trigger'); bindRange('compliance','Cml'); bindRange('resistance','R'); bindRange('effort','Effort'); bindRange('asyncPct','asyncPct'); bindRange('expLimit','expLimit'); bindRange('broncho','broncho'); bindRange('leakPct','leakPct');
  const backupType = $('#backupType'); if(backupType) backupType.addEventListener('change',()=>{ state.backupType=backupType.value; });
  refreshModeUI(); // initial

  // Disconnect toggle
  $('#disconnect').addEventListener('click', ()=>{ state.disconnected = !state.disconnected; const b=$('#disconnect'); b.textContent = `Disconnected: ${state.disconnected? 'ON':'OFF'}`; b.className = state.disconnected? 'warn' : ''; if(state.disconnected) alarmOnce('disconnect','danger','Circuit disconnected'); else clearAlarm('disconnect'); });

  // ====== Alarms (single flashing banners with tones) ======
  const alarmBar = $('#alarms');
  const activeAlarms = new Map();
  const audioCtx = (window.AudioContext? new AudioContext(): null);
  function tone(freq=880,dur=0.12,vol=0.03){
    if(!audioCtx) return; const o=audioCtx.createOscillator(); const g=audioCtx.createGain(); o.type='square'; o.frequency.value=freq; g.gain.value=vol; o.connect(g); g.connect(audioCtx.destination); o.start(); setTimeout(()=>{o.stop();}, dur*1000);
  }
  function alarmOnce(key, kind, text){
    if(activeAlarms.has(key)){ const a=activeAlarms.get(key); a.el.querySelector('span').textContent=text; return; }
    const el = document.createElement('div'); el.className=`alarm ${kind}`;
    el.innerHTML = `<strong>!</strong> <span>${text}</span> <button class="chip">Ack</button>`;
    el.querySelector('button').addEventListener('click', ()=>{ clearAlarm(key); });
    alarmBar.appendChild(el); activeAlarms.set(key,{el,kind});
    if(kind==='danger') tone(880,0.15,0.05); else if(kind==='warn') tone(660,0.12,0.04); else tone(520,0.10,0.03);
  }
  function clearAlarm(key){ const a=activeAlarms.get(key); if(!a) return; a.el.remove(); activeAlarms.delete(key); }

  // ====== Presets ======
  const scenarios = [
    {label:"Normal Lung", R:8, C:0.06, leak:0, broncho:0, Effort:0},
    {label:"Moderate ARDS", R:10, C:0.035, leak:0, broncho:0.1, Effort:0},
    {label:"Severe ARDS", R:12, C:0.02, leak:0, broncho:0.15, Effort:0},
    {label:"Severe Restrictive Pattern", R:8, C:0.015, leak:0, broncho:0.05, Effort:0},
    {label:"Mild Bronchospasm", R:12, C:0.06, leak:0, broncho:0.2, Effort:0},
    {label:"Moderate Bronchospasm", R:18, C:0.055, leak:0, broncho:0.35, Effort:0},
    {label:"Severe Bronchospasm", R:25, C:0.05, leak:0, broncho:0.55, Effort:0},
    {label:"Partial obstruction of ETT", R:28, C:0.06, leak:0, broncho:0.7, Effort:0},
    {label:"ETT disconnection/leak", R:8, C:0.06, leak:0.4, broncho:0, Effort:0},
    {label:"Ventilator-Patient asynchrony", R:10, C:0.05, leak:0.05, broncho:0.15, Effort:3}
  ];
  const scenDlg = $('#scenDlg'), scenGrid = $('#scenGrid');
  $('#scenariosBtn').addEventListener('click', ()=>{
    scenGrid.innerHTML="";
    scenarios.forEach(sc=>{
      const btn=document.createElement('button'); btn.className='chip'; btn.textContent = sc.label;
      btn.addEventListener('click', ()=>{
        state.Cml = Math.round(sc.C*1000); $('#compliance').value=state.Cml; $('#compliance').dispatchEvent(new Event('input'));
        state.R = sc.R; $('#resistance').value=state.R; $('#resistance').dispatchEvent(new Event('input'));
        state.leakPct = Math.round((sc.leak||0)*100); $('#leakPct').value=state.leakPct; $('#leakPct').dispatchEvent(new Event('input'));
        state.broncho = sc.broncho||0; $('#broncho').value=state.broncho; $('#broncho').dispatchEvent(new Event('input'));
        state.Effort = sc.Effort||0; $('#effort').value=state.Effort; $('#effort').dispatchEvent(new Event('input'));
        scenDlg.close();
      });
      scenGrid.appendChild(btn);
    });
    scenDlg.showModal();
  });
  $('#scenClose').addEventListener('click', ()=>scenDlg.close());

  // ====== Alarm setup dialog ======
  const limits = { PawHigh:45, PawLow:2, VTLow:200, VTHigh:900, MVLow:3, MVHigh:20, FIO2High:90, FIO2Low:21 };
  const alarmDlg = $('#alarmDlg'), alarmGrid = $('#alarmGrid');
  function openAlarmDlg(){
    alarmGrid.innerHTML="";
    Object.keys(limits).forEach(k=>{
      const row=document.createElement('div'); row.className='row'; row.style.gridTemplateColumns='1fr auto';
      row.innerHTML = `<label>${k}</label><input class="whiteDigits" id="lim_${k}" type="number" value="${limits[k]}">`;
      alarmGrid.appendChild(row);
    });
    alarmDlg.showModal();
  }
  $('#alarmSetupBtn').addEventListener('click', openAlarmDlg);
  $('#alarmClose').addEventListener('click', ()=>alarmDlg.close());
  $('#alarmSave').addEventListener('click', ()=>{
    Object.keys(limits).forEach(k=>{ limits[k] = Number(($('#lim_'+k).value)||limits[k]); });
    alarmDlg.close();
  });

  // ====== Controls ======
  function start(){ if(!state.running){ state.running=true; $('#status').textContent='Running'; $('#led').classList.add('on'); requestAnimationFrame(step);} }
  function pause(){ state.running=false; $('#status').textContent='Paused'; $('#led').classList.remove('on'); }
  function stop(){
    pause();
    t=0; volume=0; flow=0; p_aw=state.PEEP; p_peak=0; vt_exp=0; auto_peep=0; wobThisBreath=0;
    inPause=false; platSum=0; platN=0; lastPplat=null;
    pChart.d=[]; fChart.d=[]; vChart.d=[]; pChart.draw(); fChart.draw(); vChart.draw();
    $('#status').textContent='Stopped';
    activeAlarms.forEach((_,k)=>clearAlarm(k));
    mvEvents.length=0; breathStarts.length=0; $('#kMV').textContent='--'; $('#kRR').textContent='-- / --';
  }
  $('#start').addEventListener('click',start); $('#pause').addEventListener('click',pause); $('#stop').addEventListener('click',stop);
  $('#freeze').addEventListener('click',()=>{ state.freeze=!state.freeze; });
  $('#freezeBtn').addEventListener('click',()=>{ state.freeze=!state.freeze; });

  // ====== Helpers ======
  function markBreathStart(src){ breathStarts.push({t: nowSec(), src}); }

  // PRVC: estimate initial Pinsp from VT target and compliance
  function estimateInitialPRVCPinsp(){
    const C = Math.max(0.01, state.Cml)/1000; // L/cmH2O
    const VT_L = state.prvcVT/1000;
    const dP = VT_L / C; // cmH2O above baseline
    // use current PEEP when not APRV
    const baseline = (state.mode==='APRV') ? 0 : state.PEEP;
    const guess = Math.max(5, Math.min(state.prvcPmax, dP)); // above baseline, controller uses PEEP separately
    state.prvcPinsp = guess;
  }

  function effortSignal(){ const amp=state.Effort; if(amp<=0) return 0; if(cyclePhase==='exp' && Math.random()< Math.max(0.01,state.asyncPct/200)) { return amp; } return 0; }

  function targetPressurePC(inPhase){
    if(cyclePhase==='insp'){
      const ramp=0.08; const up=Math.min(1, inPhase/ramp);
      if(inPhase >= state._activeInsp) return peepTerm() + state.Pinsp; // pause hold
      return peepTerm() + state.Pinsp*up;
    }
    return peepTerm() + auto_peep;
  }
  function targetFlowVC(inPhase){
    if(cyclePhase==='insp'){
      if(inPhase >= state._activeInsp) return 0; // pause
      const vtL = (state.mode==='PRVC'? state.prvcVT : state.VT)/1000; return vtL/Math.max(0.3,state._activeInsp);
    }
    return -Math.max(0.02, volume/Math.max(0.3,expT))*(1-state.expLimit*0.6);
  }
  function controllerPRVC(){ // called once per cycle end of expiration
    const vt_ml = vt_exp*1000;
    const err = (state.prvcVT - vt_ml);
    const step = Math.max(-1, Math.min(1, err/150)); // ±1 cmH2O typical
    state.prvcPinsp = Math.max(5, Math.min(state.prvcPmax, (state.prvcPinsp||16) + step));
  }
  function handleAPRV(){ state.aprvTimer += SIM_DT; if(state.aprvPhase==='TH' && state.aprvTimer>=state.aprvTH){ state.aprvPhase='TL'; state.aprvTimer=0; } else if(state.aprvPhase==='TL' && state.aprvTimer>=state.aprvTL){ state.aprvPhase='TH'; state.aprvTimer=0; } }

  function peepTerm(){ return (state.mode==='APRV') ? 0 : state.PEEP; }

  function advancePhase(triggerSrc){
    if(cyclePhase==='insp'){
      // End of inspiration
      if(platN>2){ lastPplat = platSum/platN; } else { lastPplat = null; }
      inPause=false; platSum=0; platN=0;

      cyclePhase='exp'; timeInPhase=0; expStartVol=volume; vt_exp=0;
    } else {
      // Start of inspiration
      cyclePhase='insp'; timeInPhase=0;
      p_peak=0; lastPplat=null; inPause=false; platSum=0; platN=0;

      // auto-PEEP from trapped volume
      const C=Math.max(0.01,state.Cml)/1000; auto_peep = Math.max(0,volume)/C;

      markBreathStart(triggerSrc);
    }
  }

  // ====== Simulation loop ======
  let hiPawLatch=false, hiPawSince=0;
  let mvLowLatch=false, mvHighLatch=false;
  let leakLatch=false;
  let apneaLatch=false;

  function step(){
    if(!state.running){ return; }
    t+=SIM_DT; timeInPhase+=SIM_DT;

    const C=Math.max(0.01,state.Cml)/1000;
    let R=state.R*(1+0.5*state.broncho);

    // machine cycling (not used by APRV timings; APRV handled separately via timers driving pressure levels)
    if(state.mode!=='APRV'){
      if(cyclePhase==='insp' && timeInPhase>=inspT){ advancePhase('machine'); }
      else if(cyclePhase==='exp' && timeInPhase>=expT){ if(state.mode==='PRVC') controllerPRVC(); advancePhase('machine'); }
    } else {
      // In APRV, we keep continuous cycling based on TH/TL but still reuse insp/exp phases for plotting
      handleAPRV();
      // map TH -> "insp plateau", TL -> "release/exp"
      const wantInsp = (state.aprvPhase==='TH');
      if((wantInsp && cyclePhase!=='insp') || (!wantInsp && cyclePhase!=='exp')){
        // switch phase (no machine/patient semantics here)
        if(cyclePhase==='insp'){ advancePhase('machine'); } else { advancePhase('machine'); }
      }
    }

    // patient trigger surrogate (not impactful in APRV timing, but keeps responsiveness)
    const peff = effortSignal();
    if(state.mode!=='APRV' && cyclePhase==='exp' && peff>Math.abs(state.trigger)) { advancePhase('patient'); }

    // targets per mode
    let Ptarget = peepTerm(), Ftarget = 0;
    if(state.mode==='PC-AC') Ptarget = targetPressurePC(timeInPhase);
    else if(state.mode==='VC-AC') Ftarget = targetFlowVC(timeInPhase);
    else if(state.mode==='PRVC'){
      const PinspUse=Math.min(state.prvcPmax, state.prvcPinsp||16);
      if(cyclePhase==='insp'){ const ramp=0.08; const up=Math.min(1,timeInPhase/ramp); Ptarget=peepTerm()+PinspUse*up; } else Ptarget=peepTerm()+auto_peep;
    }
    else if(state.mode==='APRV'){ Ptarget = (state.aprvPhase==='TH'? state.aprvPhigh : state.aprvPlow); }
    else if(state.mode==='PSV'){
      state.apneaTimer += SIM_DT;
      if(state.apneaTimer>=state.apneaT && !state.backupActive){ state.backupActive=true; apneaLatch=true; alarmOnce('apnea','warn','Apnea: backup active'); }
      if(state.backupActive){
        const saveRR = state.RR; state.RR = state.backupRR; recalcTiming();
        if(state.backupType==='PC-AC'){ Ptarget = targetPressurePC(timeInPhase); } else { Ftarget = targetFlowVC(timeInPhase); }
        state.RR = saveRR; recalcTiming();
      } else {
        if(cyclePhase==='insp') {
          Ptarget = peepTerm() + state.ps;
          if(Math.abs(flow) > (psvPeakFlow||0)) psvPeakFlow = Math.abs(flow);
          const offThresh = (state.cyclePct/100) * (psvPeakFlow||1);
          if(Math.abs(flow) <= offThresh && timeInPhase>0.2){ advancePhase('patient'); psvPeakFlow=0; }
        } else { Ptarget = peepTerm() + auto_peep; }
        if(flow>0.3){ state.apneaTimer=0; if(apneaLatch){ clearAlarm('apnea'); apneaLatch=false; } }
      }
    }

    // controller dynamics
    if(state.mode==='VC-AC' || (state.mode==='PSV' && state.backupActive && state.backupType==='VC-AC')){
      // flow-targeted
      if(Ftarget!==0){ flow += (Ftarget - flow)*0.2; }
      else { const kExp = 1/Math.max(0.1,expT); flow += (-(volume/Math.max(0.2, C*(1+state.expLimit))) - flow)*kExp*SIM_DT*2; }
    } else {
      // pressure-targeted (PC-AC / PRVC / APRV / PSV / backup PC-AC)
      const E=1/C;
      const desired = (Ptarget) - (E*volume + R*flow + peepTerm() + auto_peep - peepTerm()); // simplify to Ptarget - Paw(no peepTerm twice)
      const tau=0.05; const dFlow = desired/Math.max(5,R) * SIM_DT/tau;
      flow += dFlow;
      if((state.mode==='PC-AC' || state.mode==='PRVC') && cyclePhase==='insp' && timeInPhase>state._activeInsp) flow += (0 - flow)*0.5; // pause to zero
    }

    // caps and leak/disconnection
    const flowCap = 2.0/(1+0.6*state.broncho + 1.2*state.expLimit);
    flow = Math.max(-flowCap, Math.min(flowCap, flow));
    let leakFlow = 0;
    if(state.disconnected){
      leakFlow = flow + Math.sign(volume)*Math.min(Math.abs(volume)/Math.max(0.05,SIM_DT), 3.0);
    } else {
      // use baseline appropriate for mode (no external PEEP in APRV calc)
      const baseline = peepTerm() + auto_peep;
      const provisionalP = (1/C)*volume + R*flow + baseline;
      const gLeak=(state.leakPct/100)*0.2; const dP=Math.max(0, provisionalP - peepTerm());
      leakFlow = gLeak*dP;
    }
    const alveolarFlow = flow - leakFlow;
    volume += alveolarFlow * SIM_DT;

    // Airway pressure with proper baseline
    const baseline = peepTerm() + auto_peep;
    p_aw = (1/C)*volume + R*flow + baseline;

    // plateau sampling during pause (not used for APRV)
    const pauseOn = (state.mode!=='APRV' && cyclePhase==='insp' && timeInPhase>=state._activeInsp && state.tpct>0);
    if(pauseOn){ inPause = true; platSum += p_aw; platN += 1; }

    // WOB, Vt exp, peaks
    if(cyclePhase==='insp' && (state.mode==='APRV' || timeInPhase<=state._activeInsp)){ wobThisBreath += Math.max(0,(p_aw - peepTerm())) * Math.max(0,alveolarFlow) * SIM_DT; }
    if(cyclePhase==='exp') vt_exp = Math.max(vt_exp,(expStartVol - volume));
    if(cyclePhase==='insp') p_peak=Math.max(p_peak,p_aw);

    // === MV window using timestamps ===
    if(alveolarFlow < 0){ mvEvents.push({t: nowSec(), L: Math.max(0,-alveolarFlow) * SIM_DT}); }
    const mvCut = nowSec()-MV_WINDOW_SEC; while(mvEvents.length && mvEvents[0].t<mvCut){ mvEvents.shift(); }
    let mvSumL = 0; for(const e of mvEvents) mvSumL += e.L;
    const MV = mvSumL * (60 / MV_WINDOW_SEC);

    // === RR window split set vs patient ===
    const rrCut = nowSec()-RR_WINDOW_SEC; while(breathStarts.length && breathStarts[0].t<rrCut){ breathStarts.shift(); }
    let nSet=0, nPat=0; for(const b of breathStarts){ if(b.src==='machine') nSet++; else if(b.src==='patient') nPat++; }
    const rrSet = nSet * (60 / RR_WINDOW_SEC), rrPat = nPat * (60 / RR_WINDOW_SEC);

    // Charts
    if(!state.freeze){
      pChart.push(p_aw); fChart.push(flow*60); vChart.push(volume*1000);
      const pr = pChart.draw(); const fr = fChart.draw(); const vr = vChart.draw();
      if(pr){ $('#pAxis').textContent = `Scale: ${fmt(pr[0],0)} to ${fmt(pr[1],0)} cmH₂O`; }
      if(fr){ $('#fAxis').textContent = `Scale: ${fmt(fr[0],0)} to ${fmt(fr[1],0)} L/min`; }
      if(vr){ $('#vAxis').textContent = `Scale: ${fmt(vr[0],0)} to ${fmt(vr[1],0)} mL`; }
    }

    // KPIs
    $('#kRR').textContent = `${fmt(rrSet,0)} / ${fmt(rrPat,0)}`;
    $('#kMV').textContent = `${fmt(MV,1)}`;
    $('#kPpeak').textContent = `${fmt(p_peak,1)}`;
    $('#kPplat').textContent = (lastPplat==null? '--' : fmt(lastPplat,1));
    $('#kVT').textContent = `${fmt(vt_exp*1000,0)}`;
    $('#kAutoPEEP').textContent = `${fmt(auto_peep,1)}`;

    // ====== Alarms (subset shown; others as before) ======
    const hiPawThr = limits.PawHigh, vtLowThr = limits.VTLow, vtHiThr = limits.VTHigh;
    const fio2Hi = limits.FIO2High, fio2Lo = limits.FIO2Low;
    const mvLowThr = limits.MVLow, mvHighThr = limits.MVHigh;

    // High Paw (hysteresis)
    const hiPaw = p_aw>hiPawThr;
    if(hiPaw){ if(!hiPawLatch){ hiPawSince += SIM_DT; if(hiPawSince>0.12){ hiPawLatch=true; alarmOnce('hiPaw','danger',`High Paw ${fmt(p_aw,0)} cmH₂O`);} } }
    else { hiPawSince=0; if(hiPawLatch && p_aw<hiPawThr-7) { hiPawLatch=false; clearAlarm('hiPaw'); } }

    // VT alarms at breath transition
    if(cyclePhase==='insp' && timeInPhase<SIM_DT*1.5 && vt_exp>0){
      const vt_ml = vt_exp*1000;
      if(vt_ml<vtLowThr) alarmOnce('vtLow','warn',`VT Low ${fmt(vt_ml,0)} mL`); else clearAlarm('vtLow');
      if(vt_ml>vtHiThr) alarmOnce('vtHigh','warn',`VT High ${fmt(vt_ml,0)} mL`); else clearAlarm('vtHigh');
    }

    // MV low/high (latched)
    if(MV < mvLowThr) alarmOnce('mvLow','warn',`MV Low ${fmt(MV,1)} L/min`); else clearAlarm('mvLow');
    if(MV > mvHighThr) alarmOnce('mvHigh','warn',`MV High ${fmt(MV,1)} L/min`); else clearAlarm('mvHigh');

    // FiO2
    if(state.fio2>fio2Hi) alarmOnce('fio2High','warn',`FiO₂ High ${fmt(state.fio2,0)}%`); else clearAlarm('fio2High');
    if(state.fio2<fio2Lo) alarmOnce('fio2Low','warn',`FiO₂ Low ${fmt(state.fio2,0)}%`); else clearAlarm('fio2Low');

    // Disconnect/leak
    if(state.disconnected){ alarmOnce('disconnect','danger','Circuit disconnected'); }
    else { clearAlarm('disconnect'); }
    if(!leakLatch && leakFracEMA > 0.25){ leakLatch = true; alarmOnce('leak','warn',`Leak detected (~${fmt(leakFracEMA*100,0)}%)`); }
    if(leakLatch && leakFracEMA < 0.15){ leakLatch = false; clearAlarm('leak'); }

    if(state.running) requestAnimationFrame(step);
  }

  // ====== Buttons ======
  $('#start').addEventListener('click', start);
  $('#pause').addEventListener('click', pause);
  $('#stop').addEventListener('click', stop);
  $('#freeze').addEventListener('click', ()=>{ state.freeze=!state.freeze; });

})();
</script>
</body>
</html>
