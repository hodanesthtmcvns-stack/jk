<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Daily Duty Rota Transcriptor, WhatsApp-ready Text (HBCH and MPMMCC Varanasi)</title>
<style>
  :root{--bg:#0b1020;--card:#121a33;--muted:#9fb0ff;--txt:#e9ecff;--border:#28325b;--btn:#2a3cff;}
  body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;background:linear-gradient(180deg,#070a14 0%,#0b1020 45%,#070a14 100%);color:var(--txt);}
  .wrap{max-width:1100px;margin:24px auto;padding:0 16px;}
  h1{font-size:20px;margin:0 0 12px;}
  .grid{display:grid;grid-template-columns:1fr;gap:14px;}
  @media(min-width:980px){.grid{grid-template-columns: 1.15fr .85fr;}}
  .card{background:rgba(18,26,51,.92);border:1px solid var(--border);border-radius:14px;padding:14px 14px 12px;box-shadow:0 12px 30px rgba(0,0,0,.25);}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  label{font-size:12px;color:#cdd5ff}
  input[type="date"], input[type="text"], textarea{
    background:#0d1430;border:1px solid var(--border);color:var(--txt);
    border-radius:10px;padding:10px 10px;font-size:14px;outline:none;
  }
  input[type="date"]{padding:9px 10px;}
  textarea{width:100%;min-height:160px;resize:vertical;line-height:1.35}
  .small{font-size:12px;color:#cdd5ff;opacity:.95}
  .muted{color:var(--muted)}
  button{
    background:var(--btn);border:1px solid #3a4bff;color:white;border-radius:12px;
    padding:10px 12px;font-weight:600;cursor:pointer;
  }
  button.secondary{background:#182357;border-color:var(--border);}
  button.ghost{background:transparent;border-color:var(--border);color:#d7ddff;}
  button:disabled{opacity:.55;cursor:not-allowed;}
  .pill{display:inline-block;padding:2px 8px;border-radius:999px;border:1px solid var(--border);color:#d7ddff;font-size:12px}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace}
  .warn{color:#ffcc7a}
  .ok{color:#8cffc1}
  .err{color:#ff8a8a}
  .hr{height:1px;background:var(--border);margin:10px 0}
  details{border:1px solid var(--border);border-radius:12px;padding:10px;background:#0d1430}
  summary{cursor:pointer;font-weight:700;color:#dfe3ff}

  .danger{background:transparent;border:1px solid rgba(230,70,70,.6);color:#ffd0d0}
  .danger:hover{border-color:rgba(230,70,70,.95)}
</style>
</head>
<body>
<div class="wrap">
 <h1>Daily Duty Rota Transcriptor, WhatsApp-ready Text (HBCH and MPMMCC Varanasi), version 1.2 (Jan2026)</h1>
  <h4>License: GNU GPL v3. Copyright (C) [2026] [Prof. Jyotirmay Kirtania]</h4>
  <div class="small">
    Client-side only. Input: <b>Excel (.xlsx)</b> upload or <b>public Google Sheet CSV</b>. Optional: quick download from Google Sheet (manual) → then upload/load. Output: copy/download text.
    <span class="pill" id="libState" style="margin-left:8px">XLSX: loading…</span>
  </div>

  <div class="grid">
    <div class="card">
      <div class="row" style="justify-content:space-between; align-items:flex-end; gap:14px">
        <div style="flex:1">
          <label for="datePick">Select date</label><br/>
          <input id="datePick" type="date"/>
          <span id="dateHuman" class="pill" style="margin-left:8px">—</span>
        </div>
        <div style="flex:1">
          <label for="tzInfo">Timezone</label><br/>
          <input id="tzInfo" type="text" readonly value="Local browser timezone"/>
        </div>
      </div>

      <div class="hr"></div>

      <div class="row" style="margin-top:10px">
        <div style="flex:1">
          <label>Option A: Upload Excel (.xlsx)</label><br/>
          <input id="xlsxFile" type="file" accept=".xlsx,.xlsm,.xlsb,.xls"/>
          <div class="small muted">Your file stays on your computer (no upload).</div>
      </div>

      <div class="row" style="margin-top:10px">
        <div style="flex:1">
          <label>Option B: Public Google Sheet (published as CSV)</label><br/>
          <input id="csvUrl" type="text" placeholder="Paste published CSV link (or /export?format=csv&gid=...)"/>
          <div class="small muted">Must be direct CSV URL (CORS required). If it fails, use Excel download instead.</div>
          <div style="margin-top:10px"></div>
          <label class="small">OR upload a local CSV file</label><br/>
          <input id="csvFile" type="file" accept=".csv,text/csv" />
          <div class="small muted">If you downloaded a CSV (e.g., from Google Sheets export), upload it here.</div>
      </div>

<div class="row" style="gap:14px; align-items:flex-end; margin-top:12px">
        <div style="flex:1">
          <label>Quick Download (manual) — from the public Google Sheet</label><br/>
          <input id="gsViewUrl" type="text" value="https://docs.google.com/spreadsheets/d/1CDBxYfzQ0XVAPZ6lP5ZCw258L4e-gPUKsMs9wNLrGcQ/edit?usp=sharing"
                 placeholder="Paste Google Sheet public link (advanced: replace with your own)"/>
          <div class="small muted">This does <b>not</b> auto-load data into the app. It only downloads the file to your browser Downloads folder. Then use Option A (upload) as usual.</div>
        </div>
        <div class="row" style="gap:10px">
          <button id="btnDlXlsx" class="secondary" type="button">Download Excel (.xlsx)</button>
          <button id="btnDlCsv" class="secondary" type="button">Download CSV (gid from link)</button>
        </div>
      </div>

</div>
      </div>

      <div class="row" style="margin-top:10px">
        <button id="btnLoad">Load Rota Source</button>
        <button id="btnGenerate" class="secondary" disabled>Generate Text</button>
        <button id="btnCopy" class="ghost" disabled>Copy</button>
        <button id="btnDownload" class="ghost" disabled>Download .txt</button>
        <button id="btnReset" class="danger" type="button">Reset</button>
        <span id="status" class="small muted"></span>
      </div>

      <div class="hr"></div>

      <label>Output (WhatsApp / Google Docs)</label>
      <textarea id="out" class="mono" placeholder="Generated text will appear here…"></textarea>

      <details style="margin-top:10px">
        <summary>Advanced: OT preference list (editable)</summary>
        <div class="small muted" style="margin-top:8px">
          OT assignments are <b>CONSUME</b> based. Edit preferences if you want strict ordering.
          Matching is substring (case-insensitive). If no preferred available, the app picks any remaining eligible.
        </div>
        <label style="margin-top:8px">Preferences JSON</label>
        <textarea id="prefs" class="mono"></textarea>
      </details>

      <details style="margin-top:10px">
        <summary>Troubleshooting (when Generate feels “not working”)</summary>
        <div class="small muted" style="margin-top:8px">
          • If the XLSX badge shows <b>blocked/offline</b>, open the page once with internet (or ask for the fully offline bundled file).<br/>
          • Load first (<b>Load Rota Source</b>) → then Generate.<br/>
          • If date not found, the app will show the available date range for that sheet.
        </div>
      </details>
    

    <div class="card">
      <div style="font-weight:800">Guarantees</div>
      <div class="small muted" style="margin-top:8px">
        Output is always in your locked template:
        HBCH ICU → HBCH NORA/PAC/Minor GA (Major OT always prints; shows Nil if not Wed/Sat) → MPMMCC ICU → MPMMC NORA (Tue/Thu) → Brachy (Mon/Wed/Fri) → MPMMC PAC (Mon–Fri) → OT1–OT8 (G8+S9 consume) + IR (from OT4 S9) → Em OT → Day Off → Leave.
        Doctors with blank codes are never printed.
        “S0” behaves as Saturday G8; “S0^” behaves as Saturday G8^ (internally).
      </div>
    </div>
  
</div>

    </div>
</div>

<script>
let XLSX_LIB_READY = false;
(function loadXlsx(){
  const pill = document.getElementById("libState");
  const s=document.createElement("script");
  s.src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js";
  s.onload=()=>{ XLSX_LIB_READY=true; pill.textContent="XLSX: ready"; pill.className="pill ok"; };
  s.onerror=()=>{ XLSX_LIB_READY=false; pill.textContent="XLSX: blocked/offline"; pill.className="pill warn"; };
  document.head.appendChild(s);
})();

const $ = (id)=>document.getElementById(id);
const statusEl = $("status");
const outEl = $("out");

function setStatus(msg, cls="muted"){
  statusEl.className = "small " + cls;
  statusEl.textContent = msg || "";
}

function pad2(n){ return String(n).padStart(2,"0"); }
const MONTHS = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];
const WEEKDAYS = ["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"];

function toHumanDate(d){ return `${WEEKDAYS[d.getDay()]} ${d.getDate()} ${MONTHS[d.getMonth()]} ${d.getFullYear()}`; }
function toISODate(d){ return `${d.getFullYear()}-${pad2(d.getMonth()+1)}-${pad2(d.getDate())}`; }
function parseISODate(iso){
  if(!iso) return null;
  const [y,m,dd]=iso.split("-").map(Number);
  if(!y||!m||!dd) return null;
  return new Date(y,m-1,dd);
}
function dayNameFromISO(iso){
  const d = parseISODate(iso);
  return d ? WEEKDAYS[d.getDay()] : "";
}


// --- Quick Download helpers (manual workflow) ---
function extractSpreadsheetId(url){
  const s = (url || "").trim();
  const m = s.match(/\/spreadsheets\/d\/([a-zA-Z0-9-_]+)/);
  return m ? m[1] : null;
}
function extractGid(url){
  const s = (url || "").trim();
  const m = s.match(/[?&#]gid=(\d+)/);
  return m ? m[1] : "0";
}
function buildExportUrl(viewUrl, format){
  const id = extractSpreadsheetId(viewUrl);
  if(!id) throw new Error("Invalid Google Sheet link (cannot find /d/<ID>/).");
  const gid = extractGid(viewUrl);
  return `https://docs.google.com/spreadsheets/d/${id}/export?format=${format}&gid=${gid}`;
}

function normalizeCode(code){
  if (code == null) return "";
  return String(code).trim().replace(/\s+/g," ");
}

// --- Display-name mapping (codified rota name -> verbose display name) ---
const DISPLAY_NAME_MAP = {
  "Prof Jyotirmay Kirtania": "Prof J Kirtania",
  "Prof Shreyasi Ray": "Prof S Ray",
  "Dr Uddalak Chatopadhyay": "Dr Uddalak",
  "Dr Nikhil Kumar Singh": "Dr Nikhil",
  "Dr Monotosh Pramanik": "Dr Monotosh",
  "Dr Syed Sadaqat Hussain": "Dr Sadaqat",
  "Dr Souvik Mukherjee": "Dr Souvik",
  "Dr Mrunmayai H Jadhav": "Dr Mrunmayai",
  "Dr Sandipan Banerjee": "Dr Sandipan",
  "Dr Shalini Chaudhuri": "Dr Shalini",
  "Dr Shashank Tiwari": "Dr Shashank",
  "Dr Anamika Mishra": "Dr Anamika",
  "Dr Nancy (IMS BHU posting - Jan, Feb, Mar 2026)": "Dr Nancy",
  "Dr Aakriti (IMS BHU posting - Jan, Feb, Mar, April 2026)": "Dr Aakriti"
};

function displayName(raw){
  const s = (raw ?? "").toString().trim();
  if (!s) return "";
  if (DISPLAY_NAME_MAP[s]) return DISPLAY_NAME_MAP[s];
  return s.replace(/\s+/g, " ");
}

// Preference lists for single-senior selections (HBCH and MPMMCC)
const HBCH_SENIOR_PREF = ["Prof J Kirtania", "Dr Souvik", "Dr Mrunmayai", "Dr Sandipan", "Dr Nikhil"];
const MPMMCC_SENIOR_PREF = ["Dr Shashank", "Dr Souvik", "Dr Nikhil", "Dr Anamika", "Dr Sandipan"];

function pickSingleByPreference(names, prefList){
  if (!names || !names.length) return "Nil";
  const disp = names.map(displayName);
  for (const p of prefList){
    const idx = disp.findIndex(n => n.toLowerCase() === p.toLowerCase());
    if (idx >= 0) return disp[idx];
  }
  return disp[0];
}

function joinDisplayNames(arr){
  return (arr && arr.length) ? arr.map(displayName).join(", ") : "Nil";
}

const DEFAULT_PREFS = {
  "otG8Preferred": {
    "OT1": [
      "Dr Monotosh",
      "Dr Anamika",
      "Dr Sandipan",
      "Dr Souvik"
    ],
    "OT2": [
      "Dr Anamika",
      "Dr Sandipan",
      "Dr Monotosh",
      "Dr Souvik"
    ],
    "OT3": [
      "Dr Sandipan",
      "Dr Uddalak",
      "Dr Sadaqat",
      "Dr Nikhil",
      "Dr Souvik",
      "Dr Anamika"
    ],
    "OT4": [
      "Dr Sandipan",
      "Dr Uddalak",
      "Dr Sadaqat",
      "Dr Nikhil",
      "Dr Souvik",
      "Dr Anamika"
    ],
    "OT5": [
      "Prof S Ray",
      "Dr Sadaqat",
      "Dr Uddalak",
      "Dr Monotosh",
      "Dr Nikhil",
      "Dr Souvik"
    ],
    "OT6": [
      "Prof S Ray",
      "Dr Sadaqat",
      "Dr Uddalak",
      "Dr Monotosh",
      "Dr Nikhil",
      "Dr Souvik"
    ],
    "OT7": [
      "Dr Shalini",
      "Dr Souvik",
      "Dr Anamika",
      "Dr Uddalak",
      "Dr Sadaqat"
    ],
    "OT8": [
      "Dr Nikhil",
      "Dr Souvik",
      "Dr Mrunmayai",
      "Dr Sadaqat",
      "Dr Monotosh"
    ]
  },
  "otS9Preferred": {
    "OT1": [],
    "OT2": [],
    "OT3": [],
    "OT4": [],
    "OT5": [],
    "OT6": [],
    "OT7": [],
    "OT8": []
  }
};
function prefsGet(){
  try{ return JSON.parse($("prefs").value) || DEFAULT_PREFS; }
  catch(e){ throw new Error("Preferences JSON invalid."); }
}

function pickByPreference(pool, preferred){
  if (!pool.length) return null;
  if (preferred && preferred.length){
    for (const pref of preferred){
      const p = pref.toLowerCase();
      const idx = pool.findIndex(n => displayName(n).toLowerCase().includes(p));
      if (idx >= 0){
        const chosen = pool[idx];
        pool.splice(idx, 1);
        return chosen;
      }
    }
  }
  return pool.shift();
}

function joinNames(arr){ return joinDisplayNames(arr); }
function startsWithG8(code){ return /^G8/i.test(code); }
function isG8ForOT(code){ return code === "G8" || code === "S0"; }
function isG8Hat(code){ return code === "G8^" || code === "S0^"; }

let loaded = { kind:null, workbook:null, table:null, sheetName:null };

function parseCSV(csvText){
  const rows = [];
  let cur = [];
  let field = "";
  let inQuotes = false;
  for(let i=0;i<csvText.length;i++){
    const ch = csvText[i];
    const nxt = csvText[i+1];
    if(inQuotes){
      if(ch === '"' && nxt === '"'){ field += '"'; i++; }
      else if(ch === '"'){ inQuotes=false; }
      else field += ch;
    }else{
      if(ch === '"'){ inQuotes=true; }
      else if(ch === ','){ cur.push(field); field=""; }
      else if(ch === '\r'){ }
      else if(ch === '\n'){ cur.push(field); rows.push(cur); cur=[]; field=""; }
      else field += ch;
    }
  }
  if(field.length || cur.length){ cur.push(field); rows.push(cur); }
  return rows;
}

function isoDateFromAny(v){
  if (v == null) return null;
  if (v instanceof Date && !isNaN(v.getTime())) return toISODate(v);
  if (typeof v === "number" && isFinite(v) && v > 20000 && v < 60000){
    if (window.XLSX && XLSX.SSF && XLSX.SSF.parse_date_code){
      const o = XLSX.SSF.parse_date_code(v);
      if (o && o.y && o.m && o.d) return toISODate(new Date(o.y, o.m-1, o.d));
    }
    const epoch = new Date(Date.UTC(1899, 11, 30));
    const dt = new Date(epoch.getTime() + v * 86400000);
    return toISODate(new Date(dt.getUTCFullYear(), dt.getUTCMonth(), dt.getUTCDate()));
  }
  if (typeof v === "string"){
    const s = v.trim();
    if (!s) return null;
    if (/^\d{4}-\d{2}-\d{2}$/.test(s)) return s;
    const m = s.match(/^(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})$/);
    if (m){
      const d = new Date(parseInt(m[3],10), parseInt(m[2],10)-1, parseInt(m[1],10));
      if (!isNaN(d.getTime())) return toISODate(d);
    }
    const d = new Date(s);
    if (!isNaN(d.getTime())) return toISODate(d);
  }
  return null;
}

function parseMatrixFromAOA(aoa){
  let headerRow = -1;
  for (let r=0; r<Math.min(aoa.length, 80); r++){
    const c0 = (aoa[r]?.[0] ?? "").toString().toLowerCase();
    if (c0.includes("doctor")) { headerRow = r; break; }
  }
  if (headerRow === -1) throw new Error("Couldn't find header row (needs 'Doctor' in first column).");

  const firstDateColInRow = (r) => {
    const row = aoa[r] || [];
    for (let c=0; c<row.length; c++){
      if (isoDateFromAny(row[c])) return c;
    }
    return -1;
  };

  let dateRow = headerRow;
  let dateStartCol = firstDateColInRow(headerRow);
  if (dateStartCol === -1){
    dateStartCol = firstDateColInRow(headerRow+1);
    if (dateStartCol === -1) throw new Error("Couldn't detect date columns (need actual dates).");
    dateRow = headerRow+1;
  }

  const dateHeader = aoa[dateRow] || [];
  const dates = [];
  for (let c=dateStartCol; c<dateHeader.length; c++){
    const iso = isoDateFromAny(dateHeader[c]);
    if (iso) dates.push({ col:c, iso });
  }
  if (dates.length < 7) throw new Error("Too few date columns detected.");

  const doctors = [];
  const values = new Map();
  for (let r=dateRow+1; r<aoa.length; r++){
    const name = (aoa[r]?.[0] ?? "").toString().trim();
    if (!name) continue;
    if (name.toLowerCase().includes("doctor")) continue;
    doctors.push(name);
    const m = new Map();
    for (const d of dates){
      m.set(d.iso, normalizeCode(aoa[r]?.[d.col]));
    }
    values.set(name, m);
  }
  return { doctors, dates: dates.map(x=>x.iso), values };
}

function collectDocCode(matrix, dateIso){
  const docCode = new Map();
  for (const doc of matrix.doctors){
    const code = normalizeCode(matrix.values.get(doc)?.get(dateIso));
    if (code) docCode.set(doc, code);
  }
  return docCode;
}
function doctorsWithPredicate(docCode, pred){
  const out = [];
  for (const [doc, code] of docCode.entries()){
    if (pred(code, doc)) out.push(doc);
  }
  return out;
}

function generateLockedText(matrix, dateIso, prefs){
  if (!matrix.dates.includes(dateIso)){
    throw new Error(`Date ${dateIso} not found in this sheet. Available range: ${matrix.dates[0]} to ${matrix.dates[matrix.dates.length-1]}.`);
  }

  const dname = dayNameFromISO(dateIso);
  const isWed = dname === "Wednesday";
  const isSat = dname === "Saturday";
  const isTue = dname === "Tuesday";
  const isThu = dname === "Thursday";
  const isMon = dname === "Monday";
  const isFri = dname === "Friday";
  const isWeekday = ["Monday","Tuesday","Wednesday","Thursday","Friday"].includes(dname);

  const docCode = collectDocCode(matrix, dateIso);

  const hbchSeniors = doctorsWithPredicate(docCode, (code)=>startsWithG8(code) || code==="S0");
  const hbchSeniorOne = pickSingleByPreference(hbchSeniors, HBCH_SENIOR_PREF);
  const HBCH_MAJOR_S9_PREF = ["Dr Vandita", "Dr Aastha", "Dr Artee", "Dr Aayushi", "Dr Nancy", "Dr Aakriti"];
  // pick one preferred S9 for HBCH Major OT on Wed/Sat (consumed from S9 pool later)
  const s9AllToday = doctorsWithPredicate(docCode, (code)=>code==="S9");
  let hbchMajorS9 = null;
  if (dname === "Wednesday" || dname === "Saturday"){
    // find first preferred available (match by display name)
    for (const p of HBCH_MAJOR_S9_PREF){
      const idx = s9AllToday.findIndex(n => displayName(n).toLowerCase() === p.toLowerCase());
      if (idx >= 0){ hbchMajorS9 = s9AllToday[idx]; break; }
    }
    if (!hbchMajorS9 && s9AllToday.length) hbchMajorS9 = s9AllToday[0];
  }
  const hbchDay = doctorsWithPredicate(docCode, (code)=>code==="Z6H");
  const hbchEve = doctorsWithPredicate(docCode, (code)=>code==="Z7H");
  const hbchNight = doctorsWithPredicate(docCode, (code)=>code==="NIH");

  const mpmmccSeniors = doctorsWithPredicate(docCode, (code)=>isG8Hat(code));
  const mpmmccSeniorOne = pickSingleByPreference(mpmmccSeniors, MPMMCC_SENIOR_PREF);
  const mpmmccDay = doctorsWithPredicate(docCode, (code)=>code==="Z6");
  const mpmmccEve = doctorsWithPredicate(docCode, (code)=>code==="Z7");
  const mpmmccNight = doctorsWithPredicate(docCode, (code)=>code==="NI");

  const g8Pool = doctorsWithPredicate(docCode, (code)=>isG8ForOT(code)).slice();
  const s9Pool = doctorsWithPredicate(docCode, (code)=>code==="S9").filter(n => !hbchMajorS9 || n !== hbchMajorS9).slice();

  const ot = {};
  // initialize all OT slots (so OT5–OT8 print Nil on Saturdays)
  ["OT1","OT2","OT3","OT4","OT5","OT6","OT7","OT8"].forEach(k=>{ ot[k] = {g8:null, s9:null}; });
  const order = (dname === "Saturday") ? ["OT1","OT2","OT3","OT4"] : ["OT1","OT2","OT3","OT4","OT5","OT6","OT7","OT8"];
  for (const k of order){
    const g8 = pickByPreference(g8Pool, prefs?.otG8Preferred?.[k] || []);
    const s9 = pickByPreference(s9Pool, prefs?.otS9Preferred?.[k] || []);
    ot[k] = { g8, s9 };
  }

  // ---- Post-OT allocation: handle leftover S9 and leftover G8 (user rules) ----
  // At this point, g8Pool and s9Pool contain unallocated doctors (CONSUME already applied for OT1–OT8).
  const leftoverS9 = s9Pool.slice();   // remaining S9 after OT assignment
  const leftoverG8 = g8Pool.slice();   // remaining G8 after OT assignment

  let pacExtraS9 = [];
  let minorExtraS9 = [];
  let icuDayExtraS9 = [];

  let satAfternoonOT = [];

  if (dname === "Saturday") {
    // Saturday: all leftover S9 go to Afternoon OT (1pm–8pm)
    satAfternoonOT = leftoverS9.slice();
  } else if (["Monday","Tuesday","Wednesday","Thursday","Friday"].includes(dname)) {
    // Mon–Fri: distribute leftover S9 in order of preference:
    // 1) PAC (one), 2) Minor OT GA (one), 3) MPMMCC ICU Day (rest)
    const tmp = leftoverS9.slice();
    if (tmp.length) pacExtraS9.push(tmp.shift());
    if (tmp.length) minorExtraS9.push(tmp.shift());
    if (tmp.length) icuDayExtraS9 = tmp.slice();
  }

  const noraDoc = (isTue || isThu) ? ot.OT2?.s9 : null;
  const pacDoc  = (isWeekday) ? ot.OT3?.s9 : null;
  const irDoc   = ot.OT4?.s9 || null;

  const brachy = (isMon || isWed || isFri) ? "Dr J P Tiwari" : null;

  const emOt = doctorsWithPredicate(docCode, (code)=>code==="RE" || code==="WH");
  const emConsult = doctorsWithPredicate(docCode, (code)=>code==="B1" || code==="SN" || code==="EOC");

  const dayOff = doctorsWithPredicate(docCode, (code)=>code==="ABWO" || code==="ABWE");
  const leave = doctorsWithPredicate(docCode, (code)=>["CL","1/2CL","EL","DL","CCL"].includes(code));

  const d = parseISODate(dateIso);
  const L = [];
  L.push(`Rota for ${toHumanDate(d)}`);
  L.push("");

  L.push("HBCH ICU");
  L.push(`${hbchSeniorOne}`);
  L.push(`Day (9am–5:30pm): ${joinNames(hbchDay)}`);
  L.push(`Evening (1pm-9pm): ${joinNames(hbchEve)}`);
  L.push(`Night (9pm–9am): ${joinNames(hbchNight)}`);
  L.push("");

  L.push("HBCH NORA, PAC, Minor OT GA");
  L.push(`${hbchSeniorOne}`);
  L.push("HBCH Major OT:");
  if (isWed || isSat){
    L.push(`${hbchSeniorOne}${hbchMajorS9 ? ", " + displayName(hbchMajorS9) : ""}`);
  } else {
    L.push("Nil");
  }
  L.push("");

  L.push("MPMMCC ICU");
  L.push(`${mpmmccSeniorOne}${(dname === "Saturday" && leftoverG8.length) ? ", " + leftoverG8.map(displayName).join(", ") : ""}`);
  L.push(`Day (9am–5:30pm): ${joinNames(mpmmccDay)}${(leftoverG8.length || icuDayExtraS9.length) ? (joinNames(mpmmccDay) === "Nil" ? "" : ", ") + [...((dname === "Saturday") ? [] : leftoverG8), ...icuDayExtraS9].map(displayName).join(", ") : ""}`);
  L.push(`Evening (1pm-9pm): ${joinNames(mpmmccEve)}`);
  L.push(`Night (9pm–9am): ${joinNames(mpmmccNight)}`);
  L.push("");

  L.push(`MPMMC NORA: ${noraDoc ? displayName(noraDoc) : "Nil"}`);
  L.push(`Brachy OT: ${brachy ? brachy : "Nil"}`);
  L.push("");
  L.push("MPMMC PAC");
  L.push(`${pacDoc ? displayName(pacDoc) : "Nil"}${pacExtraS9.length ? ", " + pacExtraS9.map(displayName).join(", ") : ""}`);
  L.push("");

  L.push("MPMMC Major OT");
  const fmtOT = (n, key) => {
    const g = ot[key]?.g8;
    const s = ot[key]?.s9;
    const parts = [];
    if (g) parts.push(displayName(g));
    if (s) parts.push(displayName(s));
    return `OT ${n} – ${parts.length ? parts.join(", ") : "Nil"}`;
  };
  L.push(fmtOT(1,"OT1"));
  L.push(fmtOT(2,"OT2"));
  L.push(fmtOT(3,"OT3"));
  L.push(fmtOT(4,"OT4"));
  L.push(fmtOT(5,"OT5"));
  L.push(fmtOT(6,"OT6"));
  L.push(fmtOT(7,"OT7"));
  L.push(fmtOT(8,"OT8"));
  L.push(`IR / Minor OT GA – ${irDoc ? displayName(irDoc) : "Nil"}${minorExtraS9.length ? ", " + minorExtraS9.map(displayName).join(", ") : ""}`);
  if (dname === "Saturday"){
    L.push(`Afternoon OT (1pm–8pm): ${satAfternoonOT.length ? satAfternoonOT.map(displayName).join(", ") : "Nil"}`);
  }
  L.push("");

  L.push("Em OT");
  L.push(`Emergency OT (4 pm Onwards) – ${emOt.length ? joinNames(emOt) : "Nil"}`);
  L.push(`Emergency OT Consultant – ${emConsult.length ? joinNames(emConsult) : "Nil"}`);
  L.push("");

  L.push("Day Off");
  L.push(`${dayOff.length ? joinNames(dayOff) : "Nil"}`);
  L.push("");

  L.push("Leave");
  L.push(`${leave.length ? joinNames(leave) : "Nil"}`);

  return L.join("\n").trimEnd() + "\n";
}

async function loadFromExcel(file){
  if(!XLSX_LIB_READY) throw new Error("XLSX library not ready (offline/blocked). Open once with internet or use CSV route.");
  const ab = await file.arrayBuffer();
  const wb = XLSX.read(ab, {type:"array", cellDates:true});
  loaded.kind = "xlsx";
  loaded.workbook = wb;
  loaded.sheetName = wb.SheetNames[0] || null;
  setStatus(`Excel loaded. Using sheet: ${loaded.sheetName}`, "ok");
}

async function loadFromCSV(url){
  const res = await fetch(url, {mode:"cors"});
  if(!res.ok) throw new Error(`CSV fetch failed: HTTP ${res.status}`);
  const text = await res.text();
  loaded.kind = "csv";
  loaded.table = parseCSV(text);
  loaded.sheetName = "CSV";
  setStatus("CSV loaded.", "ok");
}

async function loadFromCSVFile(file){
  const text = await file.text();
  loaded.kind = "csv";
  loaded.table = parseCSV(text);
  loaded.sheetName = "CSV (" + (file.name || "local") + ")";
  setStatus("CSV file loaded.", "ok");
}

function getAOAForActiveSheet(){
  if(loaded.kind === "xlsx"){
    const ws = loaded.workbook.Sheets[loaded.sheetName];
    if(!ws) throw new Error("Sheet not found in workbook.");
    return XLSX.utils.sheet_to_json(ws, {header:1, raw:true, defval:null});
  }
  if(loaded.kind === "csv"){
    return loaded.table;
  }
  throw new Error("No source loaded.");
}

function enableOutputButtons(hasText){
  $("btnCopy").disabled = !hasText;
  $("btnDownload").disabled = !hasText;
}

(function init(){
  const now = new Date();
  $("datePick").value = toISODate(now);
  $("dateHuman").textContent = toHumanDate(now);
  $("tzInfo").value = Intl.DateTimeFormat().resolvedOptions().timeZone || "Local";
  $("prefs").value = JSON.stringify(DEFAULT_PREFS, null, 2);

  // Reset (clears loaded source + output; does not touch any external files)
  $("btnReset").addEventListener("click", ()=>{
    const ok = confirm("Reset this rota generator?\n\nThis will clear:\n• Loaded rota source (Excel/CSV)\n• Selected date\n• Preferences JSON\n• Output text\n\nYour original files are NOT affected.");
    if(!ok) return;

    loaded.kind = null;
    loaded.workbook = null;
    loaded.table = null;
    loaded.sheetName = null;

    try{
      $("xlsxFile").value = "";
      $("csvUrl").value = "";
      if($("csvFile")) $("csvFile").value = "";
      if($("datePick")) $("datePick").value = "";
      if($("prefs")) $("prefs").value = JSON.stringify(DEFAULT_PREFS, null, 2);
      if($("output")) $("output").value = "";
      $("btnGenerate").disabled = true;
      enableOutputButtons(false);
      setStatus("Reset done. Load a source and pick a date.", "muted");
    }catch(e){
      console.error(e);
      setStatus("Reset done.", "ok");
    }
  });


  // Quick Download buttons (manual step: download → then upload via Option A)
  $("btnDlXlsx").addEventListener("click", ()=>{
    try{
      const url = buildExportUrl($("gsViewUrl").value, "xlsx");
      const a = document.createElement("a");
      a.href = url;
      a.target = "_blank";
      a.rel = "noopener";
      document.body.appendChild(a);
      a.click();
      setTimeout(()=>a.remove(), 0);
      setStatus("Opening Excel download in a new tab… (save it, then upload via Option A).", "ok");
    }catch(e){
      setStatus(e.message, "err");
    }
  });

  $("btnDlCsv").addEventListener("click", ()=>{
    try{
      const url = buildExportUrl($("gsViewUrl").value, "csv");
      const a = document.createElement("a");
      a.href = url;
      a.target = "_blank";
      a.rel = "noopener";
      document.body.appendChild(a);
      a.click();
      setTimeout(()=>a.remove(), 0);
      setStatus("Opening CSV download in a new tab… (save it, then load via Option B or upload Excel).", "ok");
    }catch(e){
      setStatus(e.message, "err");
    }
  });


  $("datePick").addEventListener("change", ()=>{
    const d=parseISODate($("datePick").value);
    $("dateHuman").textContent = d ? toHumanDate(d) : "—";
  });

  $("btnLoad").addEventListener("click", async ()=>{
    try{
      setStatus("Loading…", "muted");
      const f = $("xlsxFile").files && $("xlsxFile").files[0] ? $("xlsxFile").files[0] : null;
      const cf = $("csvFile") && $("csvFile").files && $("csvFile").files[0] ? $("csvFile").files[0] : null;
      const url = $("csvUrl").value.trim();
      if (f){
        await loadFromExcel(f);
      } else if (cf){
        await loadFromCSVFile(cf);
      } else if (url){
        await loadFromCSV(url);
      } else {
        throw new Error("Upload an Excel file OR upload a CSV file OR paste a CSV link.");
      }
      $("btnGenerate").disabled = false;
      outEl.value = "";
      enableOutputButtons(false);
    }catch(e){
      console.error(e);
      setStatus(e.message, "err");
      $("btnGenerate").disabled = true;
      outEl.value = "";
      enableOutputButtons(false);
    }
  });

  $("btnGenerate").addEventListener("click", ()=>{
    try{
      if(!$("datePick").value) throw new Error("Select a date first.");
      if(!loaded.kind) throw new Error("Load the rota source first.");
      const aoa = getAOAForActiveSheet();
      const matrix = parseMatrixFromAOA(aoa);
      const prefs = prefsGet();
      const txt = generateLockedText(matrix, $("datePick").value, prefs);
      outEl.value = txt;
      setStatus(`Generated. Doctors: ${matrix.doctors.length}. Range: ${matrix.dates[0]} to ${matrix.dates[matrix.dates.length-1]}.`, "ok");
      enableOutputButtons(true);
    }catch(e){
      console.error(e);
      outEl.value = "";
      setStatus(e.message, "err");
      enableOutputButtons(false);
    }
  });

  $("btnCopy").addEventListener("click", async ()=>{
    try{
      const txt = outEl.value;
      if(!txt.trim()) return;
      await navigator.clipboard.writeText(txt);
      setStatus("Copied to clipboard.", "ok");
    }catch(e){
      setStatus("Copy failed (browser permission). Select all and copy manually.", "warn");
    }
  });

  $("btnDownload").addEventListener("click", ()=>{
    const txt = outEl.value || "";
    if(!txt.trim()) return;
    const d = parseISODate($("datePick").value) || new Date();
    const filename = `rota_${toISODate(d)}.txt`;
    const blob = new Blob([txt], {type:"text/plain;charset=utf-8"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 500);
  });

  setStatus("Load an Excel/CSV source, then Generate.", "muted");
})();
</script>
</body>
</html>
